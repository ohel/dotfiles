au GUIEnter * set lines=31 columns=107 " set window size when starting in GUI mode
let g:dlines=31 " put default window size in memory
let g:dcols=107
let g:zoom_functions = 1
set tabstop=4 " tab width
set guifont=Monospace\ 12
let g:dfont="ProggyCleanTTSZ"
let g:daltfont="Monospace"

if has('win32') || has ('win64')
    let $VIMHOME = $VIM."/vimfiles"
else
    let $VIMHOME = $HOME."/.vim"
endif

if hostname() == "minigun"
    set guifont=ProggyCleanTTSZ\ 12

elseif hostname() == "gainasus"
    let g:zoom_level=2

elseif hostname() == "predator"
    au GUIEnter * set lines=27 columns=107
    let g:dlines=27
    let g:dcols=107

    set guifont=ProggyCleanTTSZ\ 12

elseif hostname() == "oheldell"
    au GUIEnter * set lines=35 columns=130
    let g:dlines=35
    let g:dcols=130
    let g:zoom_level=2
    set tabstop=2

endif

if has('win32') || has ('win64')
    set guifont=ProggyCleanTTSZ:h12:cANSI
    let g:dfont="ProggyCleanTTSZ"
    let g:daltfont="Bitstream_Vera_Sans_Mono"
endif

function! TabOrComplete() " generic tab complete
    if col('.')>1 && strpart( getline('.'), col('.')-2, 3 ) =~ '^\w'
        if empty(&omnifunc)
            return "\<c-n>"
        else
            return "\<c-x>\<c-o>"
        endif
    else
        return "\<Tab>"
    endif
endfunction
inoremap <tab> <c-r>=TabOrComplete()<cr>
" insert real tab on shift-tab
inoremap <s-tab> <c-q><tab>
" TODO: for some reason (YCM?) mapping tab in vimrc does not work
function! LoadTabOrComplete() 
    inoremap <tab> <c-r>=TabOrComplete()<cr>
    inoremap <s-tab> <c-q><tab>
endfunction
nnoremap <a-t> :call LoadTabOrComplete()<cr>

if !filereadable(expand("~/.vim/colors/minigun.vim"))
    echo("Downloading color scheme...")
    silent !curl -fLo ~/.vim/colors/minigun.vim --create-dirs https://raw.githubusercontent.com/ohel/dotfiles/master/themes/minigun.vim
endif
colorscheme minigun

set encoding=utf-8
set showtabline=2 " tab selector always visible
set expandtab " expand tab to spaces, use c-q<tab> for real tab
let &shiftwidth=&tabstop " set intend (using keys << or >>) width
let &softtabstop=&tabstop " set indent width in insert mode using tab
set hidden " do not close file buffers when opening a new one, use :ls to list buffers
set hlsearch " highlight search
set autoread " automatically update file if changed from the outside
set backspace=indent,eol,start " make backspace clear other than new text also
set guicursor=n-v-c:hor25-Cursor " set cursor size
set nocp " nocompatible: enables features which are not Vi compatible
set ic " set ignore case on searches, remedy with set noic or use \C in search term
set clipboard=unnamedplus " alias unnamed register to +
set number  " line numbering
set textwidth=0 " define text width if autowrapping: 0 disables autowrap, wraps to 80 on manual wrap (gq)
let g:leave_my_textwidth_alone=1 " don't autowrap lines while typing
let g:netrw_list_hide='\(^\|\s\s\)\zs\.\S\+' " hide dotfiles by default in Netrw Directory Listing
set go-=T " hide toolbar
set go-=m " hide menu
set go-=t " disable tear-off menus
set go-=r " disable right scroll bar
set incsearch " incremental search
set virtualedit=block " allow selecting non-characters in visual block mode
" set swap directory
"if isdirectory("~/.vim")
"   set directory=~/.vim
"endif
set noswapfile
silent !mkdir -p "$HOME/.vim/undodir"
set undodir=~/.vim/undodir
set undofile
autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif " returns cursor to previous position when opening files
:set pastetoggle=<f4> " toggle paste mode (no auto indent)



" syntax and file type detection etc.
syntax on
filetype on
au BufNewFile,BufRead *.xaml set filetype=xml
au BufNewFile,BufRead *.md set filetype=markdown
autocmd FileType python set omnifunc=pythoncomplete#Complete
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
autocmd FileType css set omnifunc=csscomplete#CompleteCSS
autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags
autocmd FileType cpp set tags +=~/.vim/ctagsdb
"ctags -R -f ctagsdb --c++-kinds=+p --fields=+iaS --extra=+q /usr/lib64/gcc/x86_64-pc-linux-gnu/$(ls -t1 /usr/lib64/gcc/x86_64-pc-linux-gnu/)/include/
nnoremap <c-f1> :!ctags -R -f ~/.vim/ctagsdb --c++-kinds=+p --fields=+iaS --extra=+q .<cr>



" plugins
if !isdirectory(expand("~/.vim/autoload"))
    silent call mkdir($HOME . '/.vim/autoload')
endif
if !filereadable(expand("~/.vim/autoload/plug.vim"))
    echo("Downloading vim-plug...")
    silent !curl -fLo ~/.vim/autoload/plug.vim https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
endif
if !isdirectory(expand("~/.vim/bundle"))
    silent call mkdir($HOME . '/.vim/bundle')
endif
if !filereadable(expand("~/.vim/autoload/pathogen.vim"))
    echo("Downloading pathogen...")
    silent !curl -fLo ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim
endif

call plug#begin('~/.vim/plugged')
    Plug 'jreybert/vimagit'
    Plug 'justinmk/vim-gtfo'
    Plug 'kana/vim-arpeggio'
    Plug 'leafgarland/typescript-vim'
    Plug 'maksimr/vim-jsbeautify', { 'do': 'cd ~/.vim/plugged/vim-jsbeautify && git submodule update --init --recursive' }
    Plug 'Shougo/unite-outline' " Unite source providing outline view of current buffer
    Plug 'Shougo/unite.vim'
    Plug 'Shougo/vimproc.vim', { 'do': 'cd ~/.vim/plugged/vimproc.vim && make -f make_unix.mak' } " allows async operations
    Plug 'tomtom/tcomment_vim' " code commenting
    Plug 'Valloric/YouCompleteMe', { 'do': 'cd ~/.vim/plugged/YouCompleteMe && ./install.py' }
call plug#end()
if filereadable(expand("~/.vim/autoload/pathogen.vim"))
    " https://github.com/tpope/vim-pathogen
    execute pathogen#infect()
endif
if isdirectory(expand("~/.vim/bundle/tsuquyomi"))
    " https://github.com/Quramy/tsuquyomi
    autocmd FileType typescript setlocal completeopt+=menu,preview
endif
if filereadable(expand("~/.vim/plugin/taglist.vim"))
    " http://vim-taglist.sourceforge.net/
    nnoremap <f1> :TlistToggle<cr>
    inoremap <f1> <c-o>:TlistToggle<cr>
endif
if filereadable(expand("~/.vim/after/ftplugin/python_pydiction.vim"))
    " https://github.com/rkulla/pydiction
    let g:pydiction_location = '~/.vim/pydiction/complete-dict'
    let g:pydiction_menu_height = 15
endif

if executable('ag')
    set grepprg=ag\ --vimgrep\ $*
    set grepformat=%f:%l:%c:%m
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '--vimgrep -i --silent'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_rec_git_command= ['ag', '--nocolor', '--follow', '--nogroup', '-g', '']
endif
let g:unite_source_rec_async_command = ['find', '-L']
call unite#custom#profile('default', 'context', {
    \ 'prompt' : '» ',
    \ 'winheight' : 20,
    \ 'direction' : 'bot',
    \ 'short_source_names' : 1
\ })

" Unite sources
call unite#custom_source('menu', 'matchers', ['matcher_fuzzy'])
call unite#custom_source('source', 'matchers', ['matcher_fuzzy'])
call unite#custom_source('outline', 'matchers', ['matcher_fuzzy'])
call unite#custom_source('history/yank', 'matchers', ['matcher_fuzzy'])
call unite#custom_source('file_rec,file_rec/async,file_mru,file,buffer,grep', 'ignore_pattern', join([
     \ '.a$',
     \ '.aux$',
     \ '.bak$',
     \ 'bower_components/',
     \ '\.git/',
     \ '.jar$',
     \ '.lib$',
     \ 'node_modules/',
     \ '.o$',
     \ '.obj$',
     \ '.out$',
     \ '.sass-cache',
     \ '.so$',
     \ 'tmp/',
     \ '.toc$',
     \ '\.tscache/'
     \ ], '\|'))

"let mapleader = ' '
map <space> <leader>
nnoremap <leader>b :Unite buffer<cr>
nnoremap <leader>f :Unite -start-insert file_rec/async buffer<cr>
vnoremap <leader>f :Unite -start-insert file_rec/async buffer<cr><c-r>*
nnoremap <leader>g :Unite -start-insert file_rec/git buffer<cr>
vnoremap <leader>g :Unite -start-insert file_rec/git buffer<cr><c-r>*
nnoremap <leader>r :Unite grep:.:<cr>
" search selected text
vnoremap <leader>r :Unite grep:.::<c-r>*<cr>
" search current filename
nnoremap <leader>c :Unite grep:.::<c-r>=expand('%:t')<cr><cr>
" search Angular.js keywords
nnoremap <leader>a :Unite -start-insert grep:.::\\.(filter\|provider\|controller\|directive\|factory\|service)\\(\\'.+\\'<cr>
nnoremap <leader>u :UniteResume<cr>

" jsbeautify
nnoremap <leader>j :call JsBeautify()<cr>:set syntax=json<cr>

" vimagit
nnoremap <silent><leader>m :Magit<cr>

" tcomment
let g:tcommentMapLeaderOp1 = 'å'
" toggle comment for the current/selected line(s)
nmap <silent><a-c> åc
vmap <silent><a-c> å
imap <silent><a-c> <esc>åc^

let g:gtfo#terminals = { 'unix' : 'xfce4-terminal' }

" Netrw Directory Listing on new tab
nnoremap <silent><leader>n :tabe .<cr>

" sort
vnoremap <leader>s :!sort<cr>

" change directory to that of the current file
nnoremap <leader>d :cd %:h<cr>:echo "wd is now" getcwd()<cr>




" uppercase commands for typos
command W w
command Q q
command WQ wq
command Wq wq

" convert Alt Gr + space to normal space
inoremap   <space>



" save
inoremap <c-s> <c-r>=col('.') == col('$') ? "\<lt>esc>`^:w\<lt>cr>a" : "\<lt>esc>`^:w\<lt>cr>i"<cr>
nnoremap <c-s> :w<cr>

" tab navigation
nnoremap <c-tab> :tabnext<cr>
nnoremap <c-s-tab> :tabprevious<cr>
inoremap <c-tab> <c-o>:tabnext<cr>
inoremap <c-s-tab> <c-o>:tabprevious<cr>
vnoremap <c-tab> <esc>:tabnext<cr>
vnoremap <c-s-tab> <esc>:tabprevious<cr>

" select all
inoremap <c-a> <esc>gg<s-v>G

" wrap to next/previous line on arrow key presses
inoremap <silent> <left> <c-r>=col('.') == 1 ? "\<lt>c-o>gkg$" : "\<lt>left>"<cr>
inoremap <silent> <right> <c-r>=col('.') == col('$') ? "\<lt>c-o>gjg0" : "\<lt>right>"<cr>

" emulate common shift + keys functionality
inoremap <silent> <s-up> <c-o>v<up>
vnoremap <silent> <s-up> <up>
inoremap <silent> <s-down> <c-o>v<down>
vnoremap <silent> <s-down> <down>
inoremap <silent> <s-left> <c-r>=col('.') == 1 ? "\<lt>c-o>gkg$v" : "\<lt>c-o>hv"<cr>
inoremap <silent> <s-right> <c-r>=col('.') == col('$') ? "\<lt>c-o>gjg0v" : "\<lt>c-o>v"<cr>
inoremap <silent> <s-home> <left><c-o>v<home>
inoremap <silent> <s-end> <c-o>v<end><left>

" common copy hotkeys
nnoremap <c-insert> V"+y<esc>:echo "Line copied."<cr>
vnoremap <c-insert> "+y<esc>:echo "Copied."<cr>
inoremap <c-insert> <esc>`^bve
vnoremap <c-c> "+y<esc>:echo "Copied."<cr>

" common insert hotkeys
nnoremap <s-insert> "+P
inoremap <s-insert> <esc>"+pa
inoremap <c-v> <c-r>=col('.') == col('$') ? "\<lt>esc>`^\"+pa" : "\<lt>esc>`^\"+Pa"<cr>
" replace contents
vnoremap <s-insert> "_x"+P
vnoremap <c-v> "_x"+P

" common search hotkey
inoremap <c-f> <esc>`^/
nnoremap <c-f> /
vnoremap <c-f> <esc>/<c-r>*<cr>

" common search and replace hotkey
nnoremap <c-h> :%s/\v/g\|:silent noh<left><left><left><left><left><left><left><left><left><left><left><left><left><left>
vnoremap <c-h> :s/\v/g\|:silent noh<left><left><left><left><left><left><left><left><left><left><left><left><left><left>



" up/down + select for dropdown lists (c-j also works)
inoremap <a-k> <up>
inoremap <a-j> <down>
inoremap <a-h> <cr>
" mainly for taglist plugin etc. to select ergonomically
nmap <c-j> <cr>

" move screen lines
inoremap <home> <c-o>g0
inoremap <end> <c-o>g$
" these disable functionality with menus, use mapped up/down
inoremap <up> <c-o>gk
inoremap <down> <c-o>gj



" switch to alternate file (usually previously edited buffer)
inoremap <a-s> <c-o>:b#<cr>
nnoremap <a-s> :b#<cr>

" uppercase word under cursor
nnoremap <a-u> gUiw

" toggle menubar
nnoremap <f5> :if &go=~#'m'<bar>set go-=m<bar>else<bar>set go+=m<bar>endif<cr>
inoremap <f5> <esc>:if &go=~#'m'<bar>set go-=m<bar>else<bar>set go+=m<bar>endif<cr>

" insert mode toggles, grave moves to ^ (editing mark)
call arpeggio#map('i', '', 0, 'fj', '<esc>`^')
call arpeggio#map('n', '', 0, 'fj', 'i')
inoremap <c-space> <esc>`^
nnoremap <c-space> i
nnoremap <enter> i<c-r>=col('.') == col('$')-1 ? "\<lt>right>" : ""<cr>

" center search matches
nnoremap n nzz
nnoremap N Nzz

" clear search highlight
nnoremap <silent> <c-n> :silent noh<cr>

" incremental search next without highlight and select match
cnoremap <c-cr> <cr>:noh<cr>zz
cnoremap <c-n> <cr>:noh<cr>/<up>
cnoremap <a-n> <cr>NN:noh<cr>/<up>

" close window
nnoremap <a-w> <c-w>c
vnoremap <a-w> <c-w>c
inoremap <a-w> <esc><c-w>c
nnoremap <c-f4> <c-w>c
vnoremap <c-f4> <c-w>c
inoremap <c-f4> <esc><c-w>c



" relative line numbering came in vi 7.3
if version >= 703
    function! ToggleRelativeNumbering()
        if &rnu
            set rnu!
            echo "Absolute numbering set."
        else
            set relativenumber
            echo "Relative numbering set."
        endif
        return ''
    endfunction
    inoremap <silent> <f3> <c-r>=ToggleRelativeNumbering()<cr>
    nnoremap <silent> <f3> :call ToggleRelativeNumbering()<cr>
endif

function! ToggleWrap()
    if &wrap
        set nowrap
        echo "No wrap set."
    else
        set wrap
        echo "Wrap set."
    endif
    return ''
endfunction
inoremap <silent> <f2> <c-r>=ToggleWrap()<cr>
nnoremap <silent> <f2> :call ToggleWrap()<cr>

" set tab width to current line whitespace width
function! WhitespaceToTabWidth()
    normal! ^
    let tabwidth = col('.') - 1
    if tabwidth > 0
        let &tabstop=tabwidth
        let &shiftwidth=tabwidth
        let &softtabstop=tabwidth
        echo "Tab width set to" tabwidth
    endif
endfunction
nnoremap <leader><tab> :call WhitespaceToTabWidth()<cr>

" print file info
function! PrintFileInfo()
    redir => filename
    silent !echo %:p
    redir END
    let filename = substitute(filename, '.*\n\(.*\n\)', '\1', '')
    let n = confirm(filename . "\n" . &fileencoding . "\n" . &ff, "", 1, "Info")
endfunction
nnoremap <f6> :call PrintFileInfo()<cr>

" set file encoding dialog
function! SetFileEncoding()
    let n = confirm("Select file encoding:\n(current: " . &fileencoding . ")", "&UTF-8\n&ISO-8859-1\n&Cancel", 3, "Question")
    if n == 1
        set fileencoding=utf-8
    elseif n == 2
        set fileencoding=iso-8859-1
    endif
endfunction
nnoremap <f7> :call SetFileEncoding()<cr>

" set file format dialog
function! SetFileFormat()
    let n = confirm("Select format for writing the file:\n(current: " . &ff . ")", "&Unix\n&Dos\n&Mac\n&Cancel", 4, "Question")
    if n == 1
        set ff=unix
    elseif n == 2
        set ff=dos
    elseif n == 3
        set ff=mac
    endif
endfunction
nnoremap <f8> :call SetFileFormat()<cr>

" font zooming
if zoom_functions == "1"

    if !exists("g:zoom_level")
        let g:zoom_level=0
    endif

    function! GrowFont()
        let fontsize = substitute(&guifont, '[^0-9]', '', 'g')
        let fontname = substitute(&guifont, '[0-9 ]', '', 'g')
        let fontname = substitute(fontname, ':h:cANSI', '', 'g')
        if g:zoom_level == 15
            return ''
        endif
        let fontsize = fontsize + 2
        if g:zoom_level == 0
            let fontname = g:daltfont
            let fontsize = 10
        endif
        let g:zoom_level = g:zoom_level + 1
        if has("win32")
            let &guifont = fontname . ":h" . fontsize . ":cANSI"
        else
            let &guifont = fontname . " " . fontsize
        endif
        let &lines=g:dlines
        let &columns=g:dcols
        echo "Font set to: " &guifont
        return ''
    endfunction

    function! ShrinkFont()
        let fontsize = substitute(&guifont, '[^0-9]', '', 'g')
        let fontname = substitute(&guifont, '[0-9 ]', '', 'g')
        let fontname = substitute(fontname, ':h:cANSI', '', 'g')
        if g:zoom_level == 0
            return ''
        endif
        let fontsize = fontsize - 2
        if g:zoom_level == 1
            let fontname = g:dfont
            let fontsize = 12
        endif
        let g:zoom_level = g:zoom_level - 1
        if has("win32")
            let &guifont = fontname . ":h" . fontsize . ":cANSI"
        else
            let &guifont = fontname . " " . fontsize
        endif
        let &lines=g:dlines
        let &columns=g:dcols
        echo "Font set to: " &guifont
        return ''
    endfunction

    nnoremap + :call GrowFont()<cr>
    nnoremap - :call ShrinkFont()<cr>
    inoremap <c-kplus> <c-r>=GrowFont()<cr>
    nnoremap <c-kplus> :call GrowFont()<cr>
    inoremap <c-kminus> <c-r>=ShrinkFont()<cr>
    nnoremap <c-kminus> :call ShrinkFont()<cr>
    inoremap <c-mousedown> <c-r>=GrowFont()<cr>
    nnoremap <c-mousedown> :call GrowFont()<cr>
    inoremap <c-mouseup> <c-r>=ShrinkFont()<cr>
    nnoremap <c-mouseup> :call ShrinkFont()<cr>
endif

