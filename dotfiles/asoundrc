# The following environment variables are used in this config:
#
#    ALSA_OVERRIDE_PCM
#    ALSA_OVERRIDE_CTL
#    ALSA_DEFAULT_PCM
#    ALSA_DEFAULT_CTL
#    ALSA_HIFI_PCM
#    ALSA_HIFI_CTL
#    ALSA_BLUETOOTH_MAC
#
# All are optional.
# OVERRIDE overrides DEFAULT if set.
# HIFI uses DEFAULT if not set.
# DEFAULT uses asound_default below if not set.
# BLUETOOTH_MAC is used for BlueALSA device.
#
# There are two default devices, DEFAULT and OVERRIDE, to prevent reference loops such as:
#
#    ALSA_DEFAULT_PCM = eq, eq.slave = default, default.pcm = ALSA_DEFAULT_PCM
#
# Instead we will have:
#
#    ALSA_OVERRIDE_PCM = eq, eq.slave = asound_default, asound_default.pcm = ALSA_DEFAULT_PCM
#
# This enables pipelining certain devices without reference loops.
# The point of the environmental variables is to support multiple audio devices, some of which might not use a mixer.
# One may define a HIFI device for use with certain media players for example, skipping resampling.
#
# Control devices corresponding to PCM devices are defined for program compatibility.

pcm.asound_default {
    @func refer
    name { @func concat
        strings [ "pcm."
            { @func getenv
                vars [ ALSA_DEFAULT_PCM ]
                default "combo"
            }
        ]
    }
}
ctl.asound_default {
    @func refer
    name { @func concat
        strings [ "ctl."
            { @func getenv
                vars [ ALSA_DEFAULT_CTL ]
                default "hda_hw"
            }
        ]
    }
}

# Default device. Generic abstraction, does not point to any real device.
pcm.!default {
    @func refer
    name { @func concat
        strings [ "pcm."
            { @func getenv
                vars [ ALSA_OVERRIDE_PCM ]
                default "asound_default"
            }
        ]
    }
}
ctl.!default {
    @func refer
    name { @func concat
        strings [ "ctl."
            { @func getenv
                vars [ ALSA_OVERRIDE_CTL ]
                default "asound_default"
            }
        ]
    }
}

#############################
########## SPECIAL ##########
#############################

# Asymmetric device for HDA audio with Juli@ input.
pcm.combo {
    type asym
    playback.pcm "hda_out_mix_44100"
    capture.pcm "julia_ain_mix_44100"
    hint {
        show on
        description "HDA out / Juli@ analog in"
    }
}

# Null output.
pcm.null {
    type null
}

# The go-to Hi-Fi device. May be used to override mixing/resampling etc.
pcm.hifi {
    @func refer
    name { @func concat
        strings [ "pcm."
            { @func getenv
                vars [ ALSA_HIFI_PCM ]
                default "asound_default"
            }
        ]
    }
    hint {
        show on
        description "Hi-Fi output"
    }
}
ctl.hifi {
    @func refer
    name { @func concat
        strings [ "ctl."
            { @func getenv
                vars [ ALSA_HIFI_CTL ]
                default "asound_default"
            }
        ]
    }
}

# General surround downmix movie setup.
pcm.movie {
    type plug
    slave {
        format float
        pcm {
            type multi
            slaves.speakers {
                pcm "hifi"
                channels 2
            }
            bindings.0.slave speakers
            bindings.0.channel 0
            bindings.1.slave speakers
            bindings.1.channel 1
        }
    }
    route_policy duplicate
    ttable {
        0.0 0.185
        1.1 0.185
        2.0 0.185
        3.1 0.185
        4.0 0.13
        4.1 0.13
        5.0 0.5
        5.1 0.5
    }
    hint {
        show on
        description "Movie setup, downmix 5.1 to stereo, custom matrix"
    }
}

# Another general movie setup with balanced sound matrix.
pcm.movie_balanced_matrix {
    type plug
    slave {
        format float
        pcm {
            type multi
            slaves.speakers {
                pcm "hifi"
                channels 2
            }
            bindings.0.slave speakers
            bindings.0.channel 0
            bindings.1.slave speakers
            bindings.1.channel 1
        }
    }
    route_policy duplicate
    ttable {
        0.0 0.29289
        1.1 0.29289
        2.0 0.29289
        3.1 0.29289
        4.0 0.20711
        4.1 0.20711
        5.0 0.20711
        5.1 0.20711
    }
    hint {
        show on
        description "Movie setup, downmix 5.1 to stereo, balanced matrix"
    }
}

# Plug device for bs2b.
pcm.binaural {
    type plug
    slave {
        rate 44100
        pcm {
            type ladspa
            slave.pcm "asound_default"
            path "/usr/lib/ladspa"
            plugins [ {
                label bs2b # Bauer stereophonic-to-binaural DSP
                input {
                    # Lowpass frequency [Hz], feeding level [dB].
                    # 650, 9.5 = Jan Meier's preset.
                    controls [ 650 9.5 ]
                }
            } ]
        }
    }
    hint {
        show on
        description "Bauer stereophonic-to-binaural DSP @ 44.1 kHz"
    }
}

# Software volume control.
pcm.softvol {
    @args [ CARD ]
    type softvol
    slave {
        pcm "asound_default"
    }
    control {
        name "Soft Master"
        @args.CARD {
            type string
            default {
                @func refer
                name 'asound_default.pcm.card'
            }
        }
    }
    hint {
        show on
        description "Software volume control"
    }
}

# WAV recording device.
pcm.wav {
    type file
    slave.pcm "asound_default"
    format "wav"
    file { @func concat
        strings [
            { @func getenv
                vars [ HOME ]
                default "/dev/shm"
            }
        "/alsa_out.wav" ]
    }
    hint {
        show on
        description "WAV recording"
    }
}

# Virtual equalizer device.
pcm.eq {
    type plug
    slave.pcm {
        type equal
        slave.pcm "asound_default"
    }
    hint {
        show on
        description "Equalizer"
    }
}
ctl.eq {
    type equal
}

# Bluetooth device.
# The control device is implicitly called ctl.bluealsa.
# Thus the control device defined here is for compatibility reasons only.
# Also notice the --a2dp-force-audio-cd parameter for bluealsa.
pcm.bluetooth {
    type plug
    slave.pcm {
        type bluealsa
        device { @func getenv
            vars [ ALSA_BLUETOOTH_MAC ]
            default "00:00:00:00:00:00"
        }
        profile "a2dp"
    }
    hint {
        show on
        description "Bluetooth audio device"
    }
}
ctl.bluetooth {
    type bluealsa
}

##########################
########## LOOP ##########
##########################

# Loop device substreams in device 0 correspond to substreams in device 1.
# In reality there are no ins and outs, just ends: they work both ways.

pcm.loop {
    type asym
    playback.pcm "loop_playback_in"
    capture.pcm "loop_record_out"
    hint {
        show on
        description "Asymmetric ALSA loopback device"
    }
}
ctl.loop {
    type hw
    card Loopback
}

pcm.loop_playback_in {
    type plug
    slave.pcm "hw:Loopback,0,0"
    hint {
        show on
        description "ALSA playback loop in"
    }
}

pcm.loop_playback_out {
    type plug
    slave.pcm "hw:Loopback,1,0"
    hint {
        show on
        description "ALSA playback loop out"
    }
}

# Mixing loopback device.
pcm.loop_playback_in_mix {
    type plug
    slave.pcm {
        type dmix
        ipc_key 10000
        slave {
            pcm "hw:Loopback,0,0"
            format S32_LE
            periods 4
            period_size 128
            rate 44100
        }
    }
    hint {
        show on
        description "Loopback in mixer device, outputs to loop_playback_out"
    }
}

pcm.loop_record_in {
    type plug
    slave.pcm "hw:Loopback,0,1"
    hint {
        show on
        description "ALSA record loop in"
    }
}

pcm.loop_record_out {
    type plug
    slave.pcm "hw:Loopback,1,1"
    hint {
        show on
        description "ALSA record loop out"
    }
}

# The vm devices are for use with virtual machines.
# KVM audio requires a hardware device but a loopback device is fine.

pcm.loop_vm_dac_in {
    type plug
    slave.pcm "hw:Loopback,0,4"
    hint {
        show on
        description "Loop: VM DAC in (use in guest)"
    }
}

pcm.loop_vm_dac_out {
    type plug
    slave.pcm "hw:Loopback,1,4"
    hint {
        show on
        description "Loop: VM DAC out (use in host)"
    }
}

pcm.loop_vm_adc_in {
    type plug
    slave.pcm "hw:Loopback,0,5"
    hint {
        show on
        description "Loop: VM ADC in (use in host)"
    }
}

pcm.loop_vm_adc_out {
    type plug
    slave.pcm "hw:Loopback,1,5"
    hint {
        show on
        description "Loop: VM ADC out (use in guest)"
    }
}

###########################################
########## HDA INTEGRATED AUDIO ###########
###########################################

# HDA hardware digital out and analog in/out.
pcm.hda_hw {
    type hw
    card PCH
    device 0
    subdevice 0
}
ctl.hda_hw {
    type hw
    card PCH
}

# HDA hardware digital out.
pcm.hda_digital_hw {
    type hw
    card PCH
    device 1
    subdevice 0
}
ctl.hda_digital_hw {
    type hw
    card PCH
}

# Asymmetric device @ 44.1 kHz.
pcm.hda {
    type asym
    playback.pcm "hda_out_mix_44100"
    capture.pcm "hda_in_mix_44100"
    hint {
        show on
        description "HDA asymmetric @ 44.1 kHz"
    }
}

# Mixing output device.
pcm.hda_out_mix_44100 {
    type plug
    slave.pcm {
        type dmix
        ipc_key 20000
        slave {
            pcm "hda_hw"
            format S16_LE
            periods 8
            period_size 1024
            rate 44100
        }
    }
    hint {
        show on
        description "HDA mix out"
    }
}

# Mixing input device.
pcm.hda_in_mix_44100 {
    type dsnoop
    ipc_key 30000
    slave {
        pcm "hda_hw"
        format S16_LE
        rate 44100
    }
    hint {
        show on
        description "HDA mix in"
    }
}

###########################
########## HDMI ###########
###########################

# HDMI hardware.
pcm.hdmi_hw {
    type hw
    card HDMI
    device 3
    subdevice 0
}
ctl.hdmi_hw {
    type hw
    card HDMI
}

# HDMI out. The name cannot be the card name, hdmi.
pcm.hdmi_out {
    type plug
    slave {
        format S16_LE
        pcm "hdmi_hw"
    }
    hint {
        show on
        description "HDMI out"
    }
}

###############################
########## ESI JULI@ ##########
###############################

# Juli@ hardware analog in/out.
pcm.julia_analog_hw {
    type hw
    card Juli
    device 0
    subdevice 0
}
ctl.julia_analog_hw {
    type hw
    card Juli
}

# Juli@ hardware digital in.
pcm.julia_digital_hw {
    type hw
    card Juli
    device 1
    subdevice 0
}
ctl.julia_digital_hw {
    type hw
    card Juli
}

# Analog out.
pcm.julia_aout {
    type plug
    slave {
        format S32_LE
        pcm "julia_analog_hw"
    }
    hint {
        show on
        description "Juli@ analog out"
    }
}

# Analog in.
pcm.julia_ain {
    type plug
    slave {
        format S32_LE
        pcm "julia_analog_hw"
    }
    hint {
        show on
        description "Juli@ analog in"
    }
}

# Digital out.
pcm.julia_dout {
    type plug
    slave {
        format S32_LE
        pcm "julia_digital_hw"
    }
    hint {
        show on
        description "Juli@ digital out"
    }
}

# Both analog and digital out, channels separate (quad).
pcm.julia_qout {
    type plug
    slave {
        format S32_LE
        pcm {
            type multi
            slaves.dout.pcm "julia_dout"
            slaves.dout.channels 2
            slaves.aout.pcm "julia_aout"
            slaves.aout.channels 2
            bindings.0.slave aout
            bindings.0.channel 0
            bindings.1.slave aout
            bindings.1.channel 1
            bindings.2.slave dout
            bindings.2.channel 0
            bindings.3.slave dout
            bindings.3.channel 1
        }
    }
    route_policy duplicate
    ttable {
        0.0 1
        1.1 1
        2.2 1
        3.3 1
    }
    hint {
        show on
        description "Juli@ analog/digital out, quad"
    }
}

# Both analog and digital out, channels duplicated.
pcm.julia_bout {
    type plug
    slave {
        format S32_LE
        pcm {
            type multi
            slaves.dout.pcm "julia_dout"
            slaves.dout.channels 2
            slaves.aout.pcm "julia_aout"
            slaves.aout.channels 2
            bindings.0.slave aout
            bindings.0.channel 0
            bindings.1.slave aout
            bindings.1.channel 1
            bindings.2.slave dout
            bindings.2.channel 0
            bindings.3.slave dout
            bindings.3.channel 1
        }
    }
    route_policy duplicate
    ttable {
        0.0 1
        1.1 1
        0.2 1
        1.3 1
    }
    hint {
        show on
        description "Juli@ analog/digital out, stereo"
    }
}

# Asymmetric analog device @ 44.1 kHz.
pcm.julia {
    type asym
    playback.pcm "julia_aout_mix_44100"
    capture.pcm "julia_ain_mix_44100"
    hint {
        show on
        description "Juli@ analog asymmetric @ 44.1 kHz"
    }
}

# Mixing analog output device.
pcm.julia_aout_mix_44100 {
    type plug
    slave.pcm {
        type dmix
        ipc_key 40000
        slave {
            pcm "julia_analog_hw"
            format S32_LE
            periods 8
            period_size 1024
            rate 44100
        }
    }
    hint {
        show on
        description "Juli@ analog out mix @ 44.1 kHz"
    }
}

# Mixing analog input device.
pcm.julia_ain_mix_44100 {
    type plug
    slave.pcm {
        type dsnoop
        ipc_key 50000
        slave {
            pcm "julia_analog_hw"
            rate 44100
        }
    }
    hint {
        show on
        description "Juli@ mix analog in 44.1 kHz"
    }
}
